library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use work.LogPackage.all;

entity BarrelShifter is
    generic(N : integer := 64);
    port(
        Input      : in  std_logic_vector(N-1 downto 0);   -- value to shift
        Arith      : in  std_logic_vector(N-1 downto 0);   -- ALU passthrough value
        ShiftFN    : in  std_logic_vector(1 downto 0);     -- 00 passthrough, 01 SLL, 10 SRL, 11 SRA
        ExtWord    : in  std_logic;
        ShiftCount : in  std_logic_vector(log2(N)-1 downto 0);
        Output     : out std_logic_vector(N-1 downto 0)
    );
end entity BarrelShifter;

architecture rtl of BarrelShifter is

    ------------------------------------------------------------------------
    -- Bit-reverse helper (for SLL)
    ------------------------------------------------------------------------
    function reverse_any_vector(a : std_logic_vector) return std_logic_vector is
        variable r : std_logic_vector(a'range);
        alias aa : std_logic_vector(a'reverse_range) is a;
    begin
        for i in aa'range loop
            r(i) := aa(i);
        end loop;
        return r;
    end function;

    constant STAGES : integer := log2(N);

    type slv_array is array (natural range <>) of std_logic_vector(N-1 downto 0);

    -- Local effective shamt (NO Quartus conflicts)
    signal eff_shamt : std_logic_vector(log2(N)-1 downto 0);

    signal src       : std_logic_vector(N-1 downto 0);
    signal stage     : slv_array(0 to STAGES);
    signal stage_in  : std_logic_vector(N-1 downto 0);
    signal stage_out : std_logic_vector(N-1 downto 0);

    signal sign_bit  : std_logic;
    signal final_res : std_logic_vector(N-1 downto 0);

begin

    ------------------------------------------------------------------------
    -- Copy ShiftCount -> eff_shamt safely, and mask for *W instructions
    ------------------------------------------------------------------------
    shamt_mask_process : process(ShiftCount, ExtWord)
    begin
        -- copy bit by bit so Quartus doesn't merge nets
        for i in eff_shamt'range loop
            eff_shamt(i) <= ShiftCount(i);
        end loop;

        -- mask high bits if this is a *W instruction
        if ExtWord = '1' then
            for i in eff_shamt'high downto 5 loop
                eff_shamt(i) <= '0';
            end loop;
        end if;
    end process;

    ------------------------------------------------------------------------
    -- Preconditioning of Input for W shifts (upper bits behavior)
    ------------------------------------------------------------------------
    process(Input, ExtWord, ShiftFN)
    begin
        src <= Input; -- default

        if ExtWord = '1' then
            case ShiftFN is
                when "10" =>  -- SRLW
                    src(N-1 downto 32) <= (others => '0');

                when "11" =>  -- SRAW
                    src(N-1 downto 32) <= (others => Input(31));

                when others =>
                    null;
            end case;
        end if;
    end process;

    ------------------------------------------------------------------------
    -- SLL uses bit reverse trick
    ------------------------------------------------------------------------
    stage_in <= reverse_any_vector(src) when ShiftFN = "01" else src;

    -- logical shifts => 0 fill; arithmetic => sign fill
    sign_bit <= '0'      when (ShiftFN = "01" or ShiftFN = "10") else
                src(N-1) when  ShiftFN = "11" else
                '0';

    ------------------------------------------------------------------------
    -- Right barrel network
    ------------------------------------------------------------------------
    stage(0) <= stage_in;

    gen_stages : for i in 0 to STAGES-1 generate
        constant S : integer := 2**i;
    begin
        stage(i+1) <=
            ((N-1 downto N-S => sign_bit) & stage(i)(N-1 downto S))
            when eff_shamt(i) = '1'
            else
            stage(i);
    end generate;

    stage_out <= reverse_any_vector(stage(STAGES)) when ShiftFN = "01"
                 else stage(STAGES);

    ------------------------------------------------------------------------
    -- Select passthrough vs shifter, then apply *W sign-extension
    ------------------------------------------------------------------------
    process(Arith, stage_out, ShiftFN, ExtWord)
    begin
        if ShiftFN = "00" then
            -- passthrough from ALU (Arith)
            if ExtWord = '1' then
                final_res(31 downto 0)  <= Arith(31 downto 0);
                final_res(63 downto 32) <= (others => Arith(31));
            else
                final_res <= Arith;
            end if;

        else
            -- actual shift operation
            if ExtWord = '1' then
                final_res(31 downto 0)  <= stage_out(31 downto 0);
                final_res(63 downto 32) <= (others => stage_out(31));
            else
                final_res <= stage_out;
            end if;
        end if;
    end process;

    Output <= final_res;

end architecture rtl;

