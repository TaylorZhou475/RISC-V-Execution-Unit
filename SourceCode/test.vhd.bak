-- Cyclone IV Optimized Brent-Kung Adder
LIBRARY ieee;
USE ieee.std_logic_1164.all;
USE ieee.math_real.all;

ENTITY BKA_CycloneIV IS
    GENERIC(
        N : NATURAL := 64  -- 64-bit adder
    );
    PORT(
        A, B  : IN  STD_LOGIC_VECTOR(N-1 downto 0);
        S     : OUT STD_LOGIC_VECTOR(N-1 downto 0);
        Cin   : IN  STD_LOGIC;
        Cout  : OUT STD_LOGIC;
        Ovfl  : OUT STD_LOGIC
    );
END ENTITY BKA_CycloneIV;

ARCHITECTURE cyclone_optimized OF BKA_CycloneIV IS
    
    -- Line 1: Function to calculate logarithm base 2
    function log2(n : natural) return natural is
        variable temp : natural := n;
        variable result : natural := 0;
    begin
        while temp > 1 loop
            temp := temp / 2;
            result := result + 1;
        end loop;
        return result;
    end function;
    
    -- Line 2: Device-specific constants for Cyclone IV
    constant NUM_LEVELS : integer := log2(N) + 1;  -- More levels for smaller fanout
    constant MAX_FANOUT : integer := 4;            -- Limited routing resources
    
    -- Line 3: Array type for storing intermediate propagate/generate values
    type level_array is array(0 to NUM_LEVELS) of std_logic_vector(N-1 downto 0);
    
    -- Line 4: Signals for the prefix tree computation
    signal P_level, G_level : level_array;
    signal Carries : std_logic_vector(N downto 0);
    
    -- Line 5: Cyclone IV synthesis attributes
    attribute keep : boolean;
    attribute keep of P_level : signal is true;
    attribute keep of G_level : signal is true;
    
begin

    -- Line 6: Generate initial Propagate and Generate signals (bit-level)
    Generate_PG : for i in 0 to N-1 generate
    begin
        -- Line 7: Propagate = A XOR B (carry propagates if either input is 1, but not both)
        P_level(0)(i) <= A(i) XOR B(i);
        
        -- Line 8: Generate = A AND B (carry generated if both inputs are 1)
        G_level(0)(i) <= A(i) AND B(i);
    end generate;

    -- Line 9: Set the initial carry input
    Carries(0) <= Cin;

    -- Line 10: Brent-Kung prefix tree construction
    tree_gen : for level in 1 to NUM_LEVELS generate
    begin
        level_gen : for i in 0 to N-1 generate
        begin
            -- Line 11: For first two levels, use small fanout of 2
            small_fanout : if level <= 2 generate
            begin
                -- Line 12: Active nodes combine with immediate neighbors
                active_small : if i >= 2**(level-1) generate
                begin
                    -- Line 13: Combined propagate = current AND previous propagate
                    -- Both segments must propagate for carry to go through
                    P_level(level)(i) <= P_level(level-1)(i) and P_level(level-1)(i - 2**(level-1));
                    
                    -- Line 14: Combined generate = current generates OR (current propagates AND previous generates)
                    -- Either this segment generates, OR it propagates what previous segment generated
                    G_level(level)(i) <= G_level(level-1)(i) or (P_level(level-1)(i) and G_level(level-1)(i - 2**(level-1)));
                end generate active_small;
                
                -- Line 15: Inactive nodes just pass through values unchanged
                inactive_small : if i < 2**(level-1) generate
                begin
                    P_level(level)(i) <= P_level(level-1)(i);
                    G_level(level)(i) <= G_level(level-1)(i);
                end generate inactive_small;
            end generate small_fanout;
            
            -- Line 16: For higher levels, use moderate fanout of 4
            medium_fanout : if level > 2 generate
            begin
                -- Line 17: Calculate the step size for this level
                -- Step increases by powers of 2, capped at MAX_FANOUT
                constant step : integer := 2**(level-1);
            begin
                -- Line 18: Active nodes combine with nodes further away
                active_medium : if i >= step generate
                begin
                    -- Line 19: Combine with node 'step' positions away
                    P_level(level)(i) <= P_level(level-1)(i) and P_level(level-1)(i - step);
                    G_level(level)(i) <= G_level(level-1)(i) or (P_level(level-1)(i) and G_level(level-1)(i - step));
                end generate active_medium;
                
                -- Line 20: Inactive nodes pass through values
                inactive_medium : if i < step generate
                begin
                    P_level(level)(i) <= P_level(level-1)(i);
                    G_level(level)(i) <= G_level(level-1)(i);
                end generate inactive_medium;
            end generate medium_fanout;
        end generate level_gen;
    end generate tree_gen;

    -- Line 21: Generate carry signals from the final level generate signals
    carry_gen : for i in 0 to N-1 generate
    begin
        -- Line 22: Carry for bit i+1 comes from the generate signal at position i
        -- G_level(NUM_LEVELS)(i) means "carry generated from bit 0 up to bit i"
        Carries(i+1) <= G_level(NUM_LEVELS)(i);
    end generate;

    -- Line 23: Compute final sum bits
    ComputeSum : for i in 0 to N-1 generate
    begin
        -- Line 24: Sum = Propagate XOR Carry
        -- If propagate is 1, sum is inverse of carry; if 0, sum matches A/B inputs
        S(i) <= P_level(0)(i) xor Carries(i);
    end generate;

    -- Line 25: Carry out is the final carry signal
    Cout <= Carries(N);
    
    -- Line 26: Overflow detection for signed arithmetic
    -- Overflow occurs when carry into MSB â‰  carry out of MSB
    Ovfl <= Carries(N) XOR Carries(N-1);

end ARCHITECTURE cyclone_optimized;